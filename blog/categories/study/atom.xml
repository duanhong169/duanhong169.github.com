<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Study | 弘's blog]]></title>
  <link href="http://duanhong169.github.com/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://duanhong169.github.com/"/>
  <updated>2012-05-17T17:01:25+08:00</updated>
  <id>http://duanhong169.github.com/</id>
  <author>
    <name><![CDATA[弘哥保护你]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Smack设置隐身状态]]></title>
    <link href="http://duanhong169.github.com/blog/smack-invisibility.html"/>
    <updated>2012-04-18T18:01:00+08:00</updated>
    <id>http://duanhong169.github.com/blog/smack-invisibility</id>
    <content type="html"><![CDATA[<p>什么是Smack？
Smack is a library for communicating with XMPP servers to perform real-time communications, including instant messaging and group chat.
<a href="http://www.igniterealtime.org/builds/smack/docs/latest/documentation/overview.html">[1]</a>Smack是一个用于与XMPP服务器通讯的Java类库，它使得我们可以方便的通过XMPP协议来进行即时通讯，群聊等。</p>

<p>新浪微博的即时通讯功能也是基于XMPP协议实现的，因此我们可以通过任何支持XMPP协议的客户端来连接它，从而使用它来与新浪微博中互相关注的好友进行聊天，这些聊天记录也会以私信的方式保存在新浪微博里。新浪微博的XMPP服务器地址是xmpp.weibo.com，端口是缺省的5222端口，用户名可以是你注册的邮箱或者是你的UID，可以到<a href="http://jwchat.org/">JWChat</a>测试一下连接。如图。</p>

<!--more-->


<p><a href="http://segmac.com/wp-content/uploads/2012/04/JWChat_login.png"><img src="http://segmac.com/wp-content/uploads/2012/04/JWChat_login_thumb.png" alt="JWChat_login" /></a>
对于通常的聊天客户端来说，用户一般都需要使用到“隐身（invisibility）”状态，即自身对于其他用户是离线的状态，而自身却依然能够接收到其他用户发来的消息。在Smack中用户通过向服务器发送<a href="http://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/packet/Presence.html">Presence</a>包来设置自己的状态，通过发送这个数据包可以向服务器发送一些与用户状态相关的请求，设置Presence的<a href="http://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/packet/Presence.Type.html">Type</a>属性可以用于说明该Presence包的用途（包括上线（available）、下线（unavailable）、请求订阅其他用户的状态（subscribe）、允许其他用户订阅自己的状态（subscribed）等等），通过设置Presence的<a href="http://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/packet/Presence.Mode.html">Mode</a>属性用于说明自己当前的状态（包括了在线（available）、离开（away）、等待聊天（chat）、忙碌（dnd）、长时间离开（xa）等状态），在Smack的较早版本中的Presence是可以直接设置为隐身（invisibility）的，然而这却违反了XMPP RFC，因此在2006年的6月就已经将这个隐身状态从Smack API中移除了<a href="http://issues.igniterealtime.org/browse/SMACK-147?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab">[2]</a>。</p>

<p>XMPP RFC认为隐身实际上是一个不必要独立存在的一个状态，因为在实际应用时，只要你不给你的其他联系人发送available类型的Presence，那么你的联系人就是不会看见你在线的，也就是达到了和隐身相同的效果，XMPP文档<a href="http://xmpp.org/extensions/xep-0126.html">XEP-0126</a>对于这种隐身功能的实现做了十分详细的说明。</p>

<p>那么在Smack中如何实现隐身状态呢，事实上有一种简单的实现办法，虽然不确定它的完善性，但是还是在一定程度上可用的。在这里对这种简单的实现做一个描述，可用性在Android平台上进行了验证。代码片段如下：
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Smack Invisibility Snippet.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">//设置状态</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">setPresence</span><span class="o">(</span><span class="kt">int</span> <span class="n">code</span><span class="o">){</span>
</span><span class='line'>    <span class="k">if</span><span class="o">(</span><span class="n">connection</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Presence</span> <span class="n">presence</span><span class="o">;</span>
</span><span class='line'>    <span class="k">switch</span><span class="o">(</span><span class="n">code</span><span class="o">){</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
</span><span class='line'>        <span class="n">presence</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Presence</span><span class="o">(</span><span class="n">Presence</span><span class="o">.</span><span class="na">Type</span><span class="o">.</span><span class="na">available</span><span class="o">);</span>
</span><span class='line'>        <span class="n">connection</span><span class="o">.</span><span class="na">sendPacket</span><span class="o">(</span><span class="n">presence</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;设置在线&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span><span class='line'>        <span class="n">presence</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Presence</span><span class="o">(</span><span class="n">Presence</span><span class="o">.</span><span class="na">Type</span><span class="o">.</span><span class="na">available</span><span class="o">);</span>
</span><span class='line'>        <span class="n">presence</span><span class="o">.</span><span class="na">setMode</span><span class="o">(</span><span class="n">Presence</span><span class="o">.</span><span class="na">Mode</span><span class="o">.</span><span class="na">dnd</span><span class="o">);</span>
</span><span class='line'>        <span class="n">connection</span><span class="o">.</span><span class="na">sendPacket</span><span class="o">(</span><span class="n">presence</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;设置忙碌&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">presence</span><span class="o">.</span><span class="na">toXML</span><span class="o">());</span>
</span><span class='line'>        <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
</span><span class='line'>        <span class="n">presence</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Presence</span><span class="o">(</span><span class="n">Presence</span><span class="o">.</span><span class="na">Type</span><span class="o">.</span><span class="na">available</span><span class="o">);</span>
</span><span class='line'>        <span class="n">presence</span><span class="o">.</span><span class="na">setMode</span><span class="o">(</span><span class="n">Presence</span><span class="o">.</span><span class="na">Mode</span><span class="o">.</span><span class="na">away</span><span class="o">);</span>
</span><span class='line'>        <span class="n">connection</span><span class="o">.</span><span class="na">sendPacket</span><span class="o">(</span><span class="n">presence</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;设置离开&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">presence</span><span class="o">.</span><span class="na">toXML</span><span class="o">());</span>
</span><span class='line'>        <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
</span><span class='line'>        <span class="n">Roster</span> <span class="n">roster</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">getRoster</span><span class="o">();</span>
</span><span class='line'>        <span class="n">Collection</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">roster</span><span class="o">.</span><span class="na">getEntries</span><span class="o">();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">RosterEntry</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">entries</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">presence</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Presence</span><span class="o">(</span><span class="n">Presence</span><span class="o">.</span><span class="na">Type</span><span class="o">.</span><span class="na">unavailable</span><span class="o">);</span>
</span><span class='line'>            <span class="n">presence</span><span class="o">.</span><span class="na">setPacketID</span><span class="o">(</span><span class="n">Packet</span><span class="o">.</span><span class="na">ID_NOT_AVAILABLE</span><span class="o">);</span>
</span><span class='line'>            <span class="n">presence</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="na">getUser</span><span class="o">());</span>
</span><span class='line'>            <span class="n">presence</span><span class="o">.</span><span class="na">setTo</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getUser</span><span class="o">());</span>
</span><span class='line'>            <span class="n">connection</span><span class="o">.</span><span class="na">sendPacket</span><span class="o">(</span><span class="n">presence</span><span class="o">);</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">presence</span><span class="o">.</span><span class="na">toXML</span><span class="o">());</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="c1">//向同一用户的其他客户端发送隐身状态</span>
</span><span class='line'>        <span class="n">presence</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Presence</span><span class="o">(</span><span class="n">Presence</span><span class="o">.</span><span class="na">Type</span><span class="o">.</span><span class="na">unavailable</span><span class="o">);</span>
</span><span class='line'>        <span class="n">presence</span><span class="o">.</span><span class="na">setPacketID</span><span class="o">(</span><span class="n">Packet</span><span class="o">.</span><span class="na">ID_NOT_AVAILABLE</span><span class="o">);</span>
</span><span class='line'>        <span class="n">presence</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="na">getUser</span><span class="o">());</span>
</span><span class='line'>        <span class="n">presence</span><span class="o">.</span><span class="na">setTo</span><span class="o">(</span><span class="n">StringUtils</span><span class="o">.</span><span class="na">parseBareAddress</span><span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="na">getUser</span><span class="o">()));</span>
</span><span class='line'>        <span class="n">connection</span><span class="o">.</span><span class="na">sendPacket</span><span class="o">(</span><span class="n">presence</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;设置隐身&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">4</span><span class="o">:</span>
</span><span class='line'>        <span class="n">presence</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Presence</span><span class="o">(</span><span class="n">Presence</span><span class="o">.</span><span class="na">Type</span><span class="o">.</span><span class="na">unavailable</span><span class="o">);</span>
</span><span class='line'>        <span class="n">connection</span><span class="o">.</span><span class="na">sendPacket</span><span class="o">(</span><span class="n">presence</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;设置离线&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="k">default</span><span class="o">:</span> <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
其中，case 3就是用于设置隐身的代码，设置隐身时，首先获取到当前的联系人列表，然后向联系人逐个发送“unavailable”状态，然后再向自己它处登录的客户端发送“unavailable”状态，而由于没有向服务器发送unavailable的状态，因此还是能够接收到联系人发送过来的消息，从而实现了隐身状态。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[P2P与PPP]]></title>
    <link href="http://duanhong169.github.com/blog/p2pppp.html"/>
    <updated>2011-12-08T00:34:07+08:00</updated>
    <id>http://duanhong169.github.com/blog/p2pppp</id>
    <content type="html"><![CDATA[<p>这两个概念非常容易搞混。这里提供一些线索供大家参考，分清楚两者之间的关系。</p>

<h2>Clue 1：简要回答</h2>

<p>Q:What is the difference between point to point and peer to peer?</p>

<p>A:Point to point is a protocol for communication between two computers using a serial interface(phone).</p>

<p>Peer to peer is a communication model in which each party has the same capabilities and either party can initiate a communication session.</p>

<!--more-->


<h2>Clue 2：概念简介</h2>

<p>PPP（Point-to-Point Protocol）</p>

<ul>
<li>是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</li>
</ul>


<p>P2P</p>

<ul>
<li><p>是一种技术，但更多的是一种思想，有着改变整个互联网基础的潜能的思想。</p></li>
<li><p>是peer-to-peer的缩写，peer在英语里有“（地位、能力等）同等者”、“同事”和“伙伴”等意义。这样一来，P2P也就可以理解为“伙伴对伙伴”的意思，或称为对等联网。目前人们认为其在加强网络上人的交流、文件交换、分布计算等方面大有前途。</p></li>
<li><p>简单的说，P2P直接将人们联系起来，让人们通过互联网直接交互。P2P使得网络上的沟通变得容易、更直接共享和交互，真正地消除中间商。P2P就是人可以直接连接到其他用户的计算机、交换文件，而不是像过去那样连接到服务器去浏览与下载。P2P另一个重要特点是改变互联网现在的以大网站为中心的状态、重返“非中心化”，并把权力交还给用户。 P2P看起来似乎很新，但是正如B2C、B2B是将现实世界中很平常的东西移植到互联网上一样，P2P并不是什么新东西。在现实生活中我们每天都按照P2P模式面对面地或者通过电话交流和沟通。</p></li>
</ul>


<h2>Clue 3：层次对比</h2>

<p>Point-to-Point是一种transmission technology，是在通信领域的范畴上来讲的，和Broadcast links构成两种“widespread use”。</p>

<p>而Peer-to-Peer(P2P)是一种网络模型或者说是一种"architechture"，"distinguishing from the Client-Server model"，指的是一种对等进程间的通信，服务器和客户机共存于一个节点，这个概念定义在一个更高的级别上，当“transmission technology”实现以后，也就是计算机通过网络联在一起以后才能有通信，从这个意义上说这两个概念有一个先后的问题。</p>

<h2>Clue 4：层次对比</h2>

<p>point to point是相对于broadcast的一种网络技术分类形式，而peer to peer 指的是网络中的对等模型，peer to peer communication属于person to person communication中的一种网络应用，而point to point是指网络连接的方式。</p>

<p>broadcast与point to point是指传输的基本设施，即如何安排连接的链路，表明的是一种拓扑关系，而P2P是基于这种基本设施上的传送行为。低层基础设施（Infrastructure）用point to point网络，高层应用（Application）可以用p2p模式；低层基础设施用broadcast网络，高层应用同样可以用p2p模式；同样的，低层基础设施用point to point网络，高层应用可以用C/S模式；低层基础设施用broadcast网络，高层应用同样可以用C/S模式。</p>

<h2>Clue 5：引申知识</h2>

<p>基础设施上的传送行为，或曰传送操作模式（分三类，即Broadcasting、Multicasting和Unicasting），这是介于上述两个层面之间的又一个层面的问题：</p>

<ul>
<li><p>在Broadcast networks和Point-to-point networks上，都可以Unicasting，这一个发送者和一个接收者之间，从应用的层面来看，既可以是不对等的关系（即采用C/S模式），也可以是对等的关系（即采用p2p模式）；</p></li>
<li><p>在Broadcast networks和Point-to-point networks上，都还可以Multicasting（或Broadcasting），这一个发送者和多个（或其它所有）接收者中的每一个接收者之间，从应用的层面来看，同样是既可以采用C/S模式，也可以采用p2p模式。</p></li>
</ul>


<h2>Clue 6：PPP引申</h2>

<p>点到点（网络拓扑）：</p>

<ul>
<li><p>永久连接（专用的）：两个端点之间的网络是永久性的连接的，就像小时候学习物理时的“绳子电话”一样。</p></li>
<li><p>交换网络：借助于电路交换和分组交换技术，点对点的连接可以动态的建立，并且在不需要该链接时自动断开。即经典的电话交换网模型。</p></li>
</ul>


<p>点对点（协议）：</p>

<ul>
<li>互联网协议族的一部分，工作在数据链路层。它通常用在两节点间建立直接的连接，主要利用串口线来连接两台计算机，现在也有用在宽带计算机连接上。很多ISP使用PPPoE（over Ethernet）给用户提供接入服务。</li>
</ul>


<h2></h2>

<h2>Clue 7：P2P引申</h2>

<p>peer-to-peer， 简称P2P，又称对等互联网络技术，是一种网络新技术，依赖网络中参与者的计算能力和带宽，而不是把依赖都聚集在较少的几台服务器上。请注意与point-to-point之间的区别，peer-to-peer一般译为端对端或者群对群，指对等网中的节点；point-to-point一般译为点对点，对应于普通网络节点。P2P网络通常用于通过Ad Hoc连接来连接节点。这类网络可以用于多种用途，各种文件共享软件已经得到了广泛的使用。P2P技术也被使用在类似VoIP等实时媒体业务的数据通信中。</p>

<p>纯点对点网络没有客户端或服务器的概念，只有平等的同级节点，同时对网络上的其它节点充当客户端和服务器。这种网络设计模型不同于客户端-服务器模型，在客户端-服务器模型中通信通常来往于一个中央服务器。</p>

<p>有些网络（如Napster、OpenNAP，或IRC @find）的一些功能（比如搜索）使用客户端-服务器结构，而使用P2P结构来实现另外一些功能。类似Gnutella或Freenet的网络则使用纯P2P结构来实现全部的任务。</p>

<p>一般报章都称P2P是点对点技术，但其实是错的，实为解作群对群（Peer-to-Peer）。在虚拟私人网络VPN (Virtual Private Network)中，也有P2P这个名称，它才是真正解作点对点（Point-to-Point）。</p>

<p><strong>依中央化程度</strong></p>

<ul>
<li>纯P2P——Gnutella</li>
</ul>


<blockquote><p>设想一个大的由用户（称为“节点”）组成的环，每个节点都有Gnutella客户端软件运行。当初始启动时，客户端软件必须进行自举（Bootstrapping）并找到至少一个其它节点，有多种不同的方法可以达到这一功能，包括软件内置的一组正在工作的已经存在的地址列表，Web缓存的已知节点更新（称为 GWebCaches）, UDP服务器缓存以及IRC。一旦连接上，客户端就会请求一张活动地址列表。</p></blockquote>

<p>当用户想要进行搜索时，客户向每一个活动联接节点发送请求。在历史上（协议0.4版本），一个客户的活动联接节点数十分小（大约是5），所以每一个收到请求的联接节点都会再向其自身的所有联接节点转发该条请求，如此继续下去，直到该请求数据包在网络中被转发的“跳数”超过一个预先设定的数值（最大为7）。</p>

<p>到了0.6版之后，Gnutella网络中的节点被划分为叶节点（leaf nodes）与超节点（ultra nodes 或 ultrapeers）。 每个叶节点仅与少数（一般为3）超节点连接，而每一个超节点与多于32个的其它超节点相连。在这种更高的出度（outdegree）下，先前提到的一条查询在网络中能达到的最大“跳数”被降低到4。</p>

<p>叶节点与超节点利用查询路由协议（Query Routing Protocol）来交换查询路由表（Query Routing Table (QRT)）。叶节点将它的QRT发送到每一个与之连接的超节点，超节点随后将每一个与之相连接的叶节点传来的QRT以及其本身的QRT合并，并且将其与自身的邻居节点交换。</p>

<p>在实际中，这种在Gnutella网络中的搜索模式是十分不可靠的。由于每一个节点都是一台普通的计算机用户，他们经常连接或者断开网络，所以整个Gnutella网络结构永远都不是完全稳定的。Gnutella网络搜索的带宽消耗也是随着连接用户的增加而指数递增的[1]，经常饱和的连接会导致较慢的节点失去作用。因此，搜索请求在网络中会被经常丢弃，与整个网络相比，大多数的查询只会到达其中的很少一部分节点。</p>

<ul>
<li>杂P2P——Napster</li>
</ul>


<blockquote><p>正因为其是杂的P2P，招致了音像界对其大规模侵权行为的非难。在法庭的责令下该服务已经终止，它却给点对点文件共享程序——如Kazaa，Limewire和BearShare——的拓展铺好了路，对这种方式的文件共享的控制，亦变得愈加困难。</p></blockquote>

<ul>
<li>混合P2P——Skype</li>
</ul>


<blockquote><p>同时含有前面两种P2P的特点。Skype软件会在电脑上打开一个网络连接端口来监听其他Skype用户的连接调用；当其他电脑能顺利连接到这部电脑，Skype称呼该用户为“Super node”（超级节点）。Super Node在该P2P环境中的角色，即为提供其他无法连接的用户的之间的中继站，借用诸多Super Nodes的些许网络带宽，协助其他的Skype用户之间能够顺利的互相联系。这种行为，在P2P环境中，这算是相当常见的手法，也是点对点连接的精髓之一。Skype是第一个将此种做法运用到网络语音通话与实时消息应用层面上。</p></blockquote>

<p>Skype在台湾是与网络家庭（PChome Online）合作，推出的Skype称为PChome &amp; Skype。在中国大陆，Skype与TOM集团旗下北京讯能网络有限公司TOM在线合作，所推出的Skype又称为TOM &amp; Skype。但是注意，由于中共政府的存在，TOM &amp; Skype被修改为明文传输以便于政府监控公民。在香港，Skype与和记环球电讯合作，推出的Skype称为HGC-Skype。在日本则与Buffalo和Excite合作。</p>

<blockquote><p>2011年5月10日，微软宣布以85亿美元现金并购了Skype。 2011年10月14日微软宣布完成这项85亿美元现金并购交易程序，Skype 首席执行官 Tony Bates 转任微软Skype事业部总裁</p></blockquote>

<p><strong>依网络拓扑结构划分</strong></p>

<ul>
<li>结构P2P</li>
</ul>


<blockquote><p>点对点之间互有连结信息，彼此形成特定规则拓扑结构。需要请求某资源时，依该拓扑结构规则查找，若存在则一定找得到。如Chord、CAN。</p></blockquote>

<ul>
<li>无结构P2P：</li>
</ul>


<blockquote><p>点对点之间互有连结信息，彼此形成无规则网状拓扑结构。需要请求某资源点时，以广播方式查找，通常会设TTL，即使存在也不一定找得到。如Gnutella。</p></blockquote>

<ul>
<li>松散结构P2P：</li>
</ul>


<blockquote><p>点对点之间互有连结信息，彼此形成无规则网状拓扑结构。需要请求某资源时，依现有信息推测查找，介于结构P2P和无结构P2P之间。如Freenet。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVM]]></title>
    <link href="http://duanhong169.github.com/blog/kvm.html"/>
    <updated>2011-11-29T20:36:01+08:00</updated>
    <id>http://duanhong169.github.com/blog/kvm</id>
    <content type="html"><![CDATA[<h2>KVM</h2>

<p>KVM（即Kernal-based Virtual Machine）是工作在包含虚拟化扩展支持（Intel VT或者AMD-V）的x86架构上的Linux的一套完整的虚拟化解决方案，它是Linux kernel的一部分，Linux kernel通过KVM来提供虚拟化的功能。使用KVM可以在一台物理机上同时运行多个无需修改的Linux或者Windows系统，并且每一个系统都拥有一套私有的虚拟硬件。</p>

<h2></h2>

<h2>QEMU</h2>

<p>QEMU是一套由Fabrice Bellard所编写的模拟处理器的自由软件。它与Bochs，PearPC近似，但其具有某些后两者所不具备的特性，如高速度及跨平台的特性。经由kqemu这个开源的加速器，QEMU能模拟至接近真实电脑的速度。QEMU有两种主要运作模式：</p>

<ul>
<li><p>User mode模拟模式，亦即是使用者模式。QEMU能启动那些为不同中央处理器编译的Linux程序。而Wine及Dosemu是其主要目标。</p></li>
<li><p>System mode模拟模式，亦即是系统模式。QEMU能模拟整个电脑系统，包括中央处理器及其他周边设备。它使得为系统源代码进行测试及除错工作变得容易。其亦能用来在一部主机上虚拟数部不同虚拟电脑。</p></li>
</ul>


<p>目前的Android模拟器就是基于QEMU开发的。</p>

<h2>KVM与QEMU</h2>

<p>由于KVM仅仅是为上层提供虚拟化的支持，它本身并不进行任何的创建或管理虚拟机的工作，而是通过一个用户空间的程序通过调用/dev/kvm接口来设置客户虚拟机的地址空间、管理I/O以及将视频显示映射回主机。QEMU就是一个可以完成这些工作的程序，可以说KVM就是借助QEMU的一部分功能来实现具体的虚拟机。</p>

<h2>KVM与Xen</h2>

<p>由于Xen、KVM都是应用在Linux虚拟化上的技术，因此有必要弄清楚它们之间的关系。Xen是一个直接工作在硬件层之上的系统，它是一个基于Nemesis微内核的hypervisor。当前各Linux发行版所包含的Xen，表面上看似乎是Xen跑在Linux系统上，实际上却是Linux跑在Xen上，只是这类发行版默认安装了一个Linux guest作为domain0，这让用户很容易产生错觉，以至于大多数的用户根本没有意识到他们正在运行一个完全不同的操作系统。</p>

<p>对于Linux最开始为什么要包含Xen，Linux的开发者ANTHONY LIGUORI称这主要是由于Linux社区的绝望。因为虚拟化在最近一段时间逐渐成为了一个很热门的技术。但是Linux过去却没有提供任何的native hypervisor的能力。大多数的Linux kernel开发者对虚拟化技术知道得也不多，因此Xen很容易的使用了一个定制的kernel，并且这个kernel还有一个相当好的community。于是Linux社区做了一个决定：包含Xen到发行版中。LIGUORI称这个决定是草率的，因为他认为正确的做法是把Linux变成一个合适的hypervisor，而不是将这个功能寄托在Xen上，他也认为其他的系统也应该像Linux这样对待这个问题。因此，可以将KVM理解为由Linux内核直接提供的对虚拟化的更好的（Linux社区有足够的自信）支持。</p>

<h2>其他</h2>

<ul>
<li><p>Xen——一个完整的系统，通常使用定制的Linux发行版作为domain0</p></li>
<li><p>virtualbox——它的部分代码由QEMU修改而来，拥有自身的图形加速</p></li>
<li><p>一套可以运行的KVM通常包括qemu-kvm和kvm-kmod两部分</p></li>
<li><p>Xen属于半虚拟化的范畴，半虚拟化指客户机操作系统是经过定制的，客户机知道自身工作在虚拟的环境中，而全虚拟化则相反</p></li>
<li><p>hypervisor，又叫VMM（Virtual Machine Manager），它相对于supervisory program（也成为内核）而言，内核的作用是负责分配计算机资源，调度，I/O等，而hypervisor处在比supervisory更高的层次上。</p></li>
<li><p>hypervisor分为两类，即Type1 和 Type 2：1类的hypervisor直接运行在裸机上，相当于hypervisor是硬件上的第一层；2类的hypervisor则是运行在传统的操作系统之上，即hypervisor是属于第2层。KVM和Xen on Linux都是属于1类，不过Xen却伪装得很像2类。</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
